// @flow

const CacheConf = require('cache-conf');
const Conf = require('conf');
const fs = require('fs-promise');
const Fuse = require('fuse.js');
const got = require('got');
const moment = require('moment');
const notifier = require('node-notifier');
const os = require('os');
const path = require('path');
const semver = require('semver');

const FileCache = require('./file-cache');
const updater = require('./updater');

/**
 * Hugo
 */
class Hugo {
    /**
     * FuseJS defaults
     * @see https://github.com/krisk/fuse#options
     * @type {Object}
     */
    _fuseDefaults: Object;

    /**
     * Hugo options
     * @type {Object}
     */
    _options: Object;

    /**
     * Output buffer
     * @type {Object}
     */
    _outputBuffer: Object;

    /**
     * Refresh (rerun) interval in seconds
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @type {number|null}
     */
    _rerun: ?number;

    /**
     * Cache store
     * @see https://www.npmjs.com/package/cache-conf
     * @type {CacheConf}
     */
    cache: CacheConf;

    /**
     * Configuration store
     * @see https://www.npmjs.com/package/conf
     * @type {Conf}
     */
    config: Conf;

    /**
     * Hugo constructor
     * @constructor
     */
    constructor() {
        // Set defaults for FuseJS
        this._fuseDefaults = {
            keys: ['title'],
            threshold: 0.4
        };

        // Save options
        this._options = {
            useTmpCache: true,
            checkUpdates: true,
            updateSource: 'packal',
            updateInterval: moment.duration(1, 'days'),
            updateNotification: true,
            updateItem: true
        };

        // Initialize output buffer
        this._outputBuffer = {};

        // Configure config store
        this.config = new Conf({
            cwd: this.workflowMeta.data
        });

        // Configure cache store
        this.cache = new CacheConf({
            configName: 'cache',
            cwd: this.workflowMeta.cache,
            version: this.workflowMeta.version
        });
    }

    /**
     * Alfred metadata
     * @return {Object}
     */
    get alfredMeta(): Object {
        let version: string = process.env.alfred_version || '0.0.0';

        // Check Alfred version for missing patch version (e.g. 3.4 is invalid, should be 3.4.0)
        if (!semver.valid(version)) {
            version += '.0';

            // Check if adding .0 to the end makes a valid version string (eg. in case of 3.4)
            if (!semver.valid(version) && process.env.alfred_debug === '1') {
                console.error(`Invalid Alfred version: ${version}`);
                version = '0.0.0';
            }
        }

        // Gather environment information
        let data: Object = {
            version: version,
            theme: process.env.alfred_theme,
            themeFile: '',
            themeBackground: process.env.alfred_theme_background,
            themeSelectionBackground: process.env.alfred_theme_selection_background,
            themeSubtext: parseFloat(process.env.alfred_theme_subtext),
            preferences: process.env.alfred_preferences,
            preferencesLocalHash: process.env.alfred_preferences_localhash,
            debug: process.env.alfred_debug === '1'
        };

        // Find and load curent Alfred theme file
        if (process.env.HOME && data.theme) {
            let homedir: string = process.env.HOME || '';

            let themeFile = path.resolve(homedir, 'Library', 'Application Support', 'Alfred ' + semver.major(version),
                'Alfred.alfredpreferences', 'themes', data.theme, 'theme.json');

            try {
                fs.statSync(themeFile);
                data.themeFile = themeFile;
            } catch (e) {
                if (process.env.alfred_debug === '1') {
                    console.error(`Could not find theme file "${themeFile}"`);
                }
            }
        }

        return data;
    }

    /**
     * Alfred theme
     * @return {Object}
     */
    get alfredTheme(): Object {
        let themeFile = this.alfredMeta.themeFile;

        if (!themeFile) {
            return {};
        }

        return fs.readJsonSync(themeFile, {throws: false}) || {};
    }

    /**
     * Alfred user input
     * @return {string}
     */
    get input(): string {
        if (process.argv.length > 3) {
            return process.argv[3] || '';
        }
        return process.argv[2] || '';
    }

    /**
     * Number of Alfred items in the current output buffer
     * @return {number}
     */
    get itemCount(): number {
        if (this.outputBuffer && this.outputBuffer.items) {
            return this.outputBuffer.items.length;
        }

        return 0;
    }

    /**
     * Current output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @return {Object} Object to be output and interpreted by Alfred
     */
    get outputBuffer(): Object {
        return this._outputBuffer;
    }

    /**
     * Workflow metadata
     * @return {Object}
     */
    get workflowMeta(): Object {
        let cacheDir = process.env.alfred_workflow_cache;
        let bundleId = process.env.alfred_workflow_bundleid;

        if (bundleId && this._options.useTmpCache === true) {
            cacheDir = path.resolve(path.join(os.tmpdir(), bundleId));
        }

        return {
            name: process.env.alfred_workflow_name,
            version: process.env.alfred_workflow_version,
            uid: process.env.alfred_workflow_uid,
            bundleId: bundleId,
            data: process.env.alfred_workflow_data,
            cache: cacheDir,
            icon: path.join(process.cwd(), 'icon.png')
        };
    }

    /**
     * Add item to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {Object} item Item to add
     * @return {Hugo}
     */
    addItem(item: Object): Hugo {
        if (!this._outputBuffer.items) {
            this._outputBuffer.items = [];
        }

        // Require item title
        if (!item.title) {
            if (this.alfredMeta.debug === true) {
                console.error('Item skipped, missing title.');
            }
            return this;
        }

        // Parse item variables
        if (item.arg && typeof item.arg === 'object') {
            let arg = item.arg.arg;
            let variables = item.arg.variables || {};

            if (semver.gte(this.alfredMeta.version, '3.4.1')) {
                // Delete item arg
                delete item.arg;

                // Only add arg when there is one
                if (arg) {
                    item.arg = arg;
                }

                // Item variables
                item.variables = Object.assign({}, item.variables, variables);
            } else {
                // Merge item.variables (new style) with item.arg.variables (old style)
                if (item.variables && typeof item.variables === 'object') {
                    variables = Object.assign({}, variables, item.variables);
                    delete item.variables;
                }

                // Build item arg (old style)
                item.arg = JSON.stringify({
                    alfredworkflow: {
                        arg: arg,
                        variables: variables
                    }
                });
            }
        } else if (item.variables && typeof item.variables === 'object' && semver.lt(this.alfredMeta.version, '3.4.1')) {
            // Build item arg (old style) with new style item variables
            item.arg = JSON.stringify({
                alfredworkflow: {
                    arg: item.arg,
                    variables: item.variables
                }
            });

            delete item.variables;
        }

        // Add item to output buffer
        this._outputBuffer.items.push(item);

        return this;
    }

    /**
     * Add items to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {Array.<Object>} items List of items to add
     * @return {Hugo}
     */
    addItems(items: Array<Object>): Hugo {
        items.map(item => {
            this.addItem(item);
            return item;
        });

        return this;
    }

    /**
     * Add session variable to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {string} key Variable key
     * @param {string} value Variable value
     * @return {Hugo}
     */
    addVariable(key: string, value: string): Hugo {
        if (!this._outputBuffer.variables) {
            this._outputBuffer.variables = {};
        }

        this._outputBuffer.variables[key] = value;

        return this;
    }

    /**
     * Add session variables to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json/
     * @param {Object} variables List of variables to add
     * @return {Hugo}
     */
    addVariables(variables: Object): Hugo {
        if (!this._outputBuffer.variables) {
            this._outputBuffer.variables = variables;
            return this;
        }

        this._outputBuffer.variables = Object.assign({}, this._outputBuffer.variables, variables);

        return this;
    }

    /**
     * Get session variable from output buffer
     * @param {string} key Variable key
     * @return {string|null} Variable value
     */
    getVariable(key: string): ?string {
        if (!this._outputBuffer.variables) {
            return null;
        }

        return this._outputBuffer.variables[key] || null;
    }

    /**
     * Get session variables from output buffer
     * @return {Object} Variables
     */
    getVariables(): Object {
        return this._outputBuffer.variables || {};
    }

    /**
     * Get item variable
     * @param {Object} item
     * @param {string} key Variable key
     * @return {string|null} Variable value
     */
    getItemVariable(item: Object, key: string): ?string {
        if (semver.gte(this.alfredMeta.version, '3.4.1')) {
            if (item.variables) {
                return item.variables[key] || null;
            }
        } else if (item.arg) {
            try {
                let arg = {};
                let variables = {};

                if (typeof item.arg === 'string') {
                    arg = JSON.parse(item.arg);
                }

                if (arg.alfredworkflow) {
                    variables = arg.alfredworkflow.variables || {};
                }

                return variables[key] || null;
            } catch (e) {}
        }

        return null;
    }

    /**
     * Get item variables
     *
     * As of Alfred 3.4.1 item variables are handled differently (properly). This method makes it easier to get the
     * variables of an item without having to deal with different versions.
     *
     * @param {Object} item
     * @return {Object} Item variables
     */
    getItemVariables(item: Object): Object {
        if (semver.gte(this.alfredMeta.version, '3.4.1')) {
            return item.variables || {};
        } else if (item.arg) {
            try {
                let arg = {};

                if (typeof item.arg === 'string') {
                    arg = JSON.parse(item.arg);
                }

                if (arg.alfredworkflow) {
                    return arg.alfredworkflow.variables || {};
                }

                return arg.variables || {};
            } catch (e) {}
        }

        return {};
    }

    /**
     * Run a callback when first script argument matches keyword. Callback will have third argument as query parameter.
     * @example node index.js myaction "my query"
     * @param {string} keyword Action name
     * @param {Function} callback Callback to execute when query matches action name
     * @return {Hugo}
     */
    action(keyword: string, callback: (query: string) => void): Hugo {
        let query: string = process.argv[2];

        if (query && callback && query === keyword) {
            query = process.argv[3] || '';
            callback(query);
        }

        return this;
    }

    /**
     * Cache processed data
     * This allows you to read and process the data once, then storing it in cache until the file has changed again.
     *
     * @param {string} filepath File path
     * @param {string} cacheName Cache name (must be unique for each file)
     * @return {FileCache}
     */
    cacheFile(filePath: string, cacheName: string): FileCache {
        return new FileCache(filePath, cacheName, this.workflowMeta.cache);
    }

    /**
     * Check for updates and notify the user
     * @async
     * @return {Promise}
     */
    async checkUpdates() {
        // No need to check if we're not showing anything, duh.
        if (this._options.checkUpdates !== true ||
                (this._options.updateItem !== true && this._options.updateNotification !== true)) {
            return;
        }

        await updater.checkUpdates(this._options.updateSource, this._options.updateInterval)
            .catch(err => {
                console.error(err);
                return;
            })
            .then(result => {
                if (!result) {
                    return;
                }

                // Version information
                let current: string = this.workflowMeta.version;
                let latest: string = result.version;

                if (!semver.valid(current)) {
                    console.error(`Version ${current} is not a valid version number.`);
                    return;
                }

                if (!semver.valid(latest)) {
                    console.error(`Could not determine latest version number.`);
                    return;
                }

                // Display notification
                if (semver.gt(latest, current)) {
                    if (result.checkedOnline === true && this._options.updateNotification === true) {
                        this.notify({
                            message: `Workflow version ${latest} available. Current version: ${current}.`
                        });
                    }
                    if (this._options.updateItem === true) {
                        this.addItem({
                            title: `Workflow update available!`,
                            subtitle: `Version ${latest} is available. Current version: ${current}.`,
                            icon: this.workflowMeta.icon,
                            arg: result.url,
                            variables: {
                                task: 'wfUpdate'
                            }
                        });
                    }
                }
            });
    }

    /**
     * Clear cache
     * @async
     * @return {Promise}
     */
    async clearCache() {
        if (this.workflowMeta.cache) {
            return fs.emptyDir(this.workflowMeta.cache);
        }
    }

    /**
     * Clear cache (sync)
     * @return {void}
     */
    clearCacheSync() {
        if (this.workflowMeta.cache) {
            return fs.emptyDirSync(this.workflowMeta.cache);
        }
    }

    /**
     * Filter added items (output buffer) with fuse.js
     * @see http://fusejs.io
     * @param {string} query Search string
     * @param {Object} options fuse.js options
     * @return {Hugo}
     */
    filterItems(query: string, options: Object = {}): Hugo {
        options = Object.assign({}, this._fuseDefaults, options);

        if (query.length === 0) {
            return this;
        }

        // Create fuse.js fuzzy search object
        let fuse = new Fuse(this._outputBuffer.items, options);

        // Set output buffer to matching items
        this._outputBuffer.items = fuse.search(query) || [];

        return this;
    }

    /**
     * Set Hugo options
     * @param {Object} options Options to set
     * @return {Hugo}
     */
    options(options: Object): Hugo {
        let cacheDirChanged = 'useTmpCache' in options && options.useTmpCache !== this._options.useTmpCache;

        // Convert updateInterval to moment.Duration object
        if (options.updateInterval && !moment.isDuration(options.updateInterval)) {
            if (options.updateInterval < 1) {
                delete options.updateInterval;
            } else {
                options.updateInterval = moment.duration(options.updateInterval, 'seconds') || moment.duration(1, 'days');
            }
        }

        // Update options
        this._options = Object.assign({}, this._options, options);

        // Update cache dir
        if (cacheDirChanged) {
            this.cache = new CacheConf({
                configName: 'cache',
                cwd: this.workflowMeta.cache,
                version: this.workflowMeta.version
            });
        }

        return this;
    }

    /**
     * Filter list of candidates with fuse.js
     * @see http://fusejs.io
     * @param {Array.<Object>} candidates Input data
     * @param {string} query Search string
     * @param {Object} options fuse.js options
     * @return {Array.<Object>}
     */
    matches(candidates: Array<Object>, query: string, options: Object = {}): Array<Object> {
        options = Object.assign({}, this._fuseDefaults, options);

        if (query.length === 0) {
            return candidates;
        }

        // Create fuse.js fuzzy search object
        let fuse = new Fuse(candidates, options);

        // Return results
        return fuse.search(query) || [];
    }

    /**
     * Send a notification
     *
     * Notification title defaults to the Workflow name, or when not available to 'Alfred'. You can adjust all the options
     * that node-notifier supports. Please see their documentation for available options.
     *
     * @see https://github.com/mikaelbr/node-notifier
     * @param {Object} options Notification options
     * @return {Promise} Notifier response
     */
    async notify(options: Object) {
        return new Promise((resolve, reject) => {
            let defaults = {
                title: ('Alfred ' + this.workflowMeta.name).trim(),
                sender: 'com.runningwithcrayons.Alfred-3',
                contentImage: this.workflowMeta.icon
            };

            // Set options
            options = Object.assign({}, defaults, options);

            // Notify
            notifier.notify(options, (err, response) => {
                if (err) {
                    reject(err);
                    return;
                }

                resolve(response);
            });
        });
    }

    /**
     * Set rerun parameter
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {number} value Interval to rerun the script when idle
     * @return {Hugo}
     */
    rerun(value: number): Hugo {
        value = parseFloat(value);

        if (value && value > 0.1 && value <= 5) {
            this._rerun = value;
        }

        return this;
    }

    /**
     * Flush the output buffer so Alfred shows our items
     * @async
     */
    async feedback() {
        if (this._rerun) {
            this._outputBuffer.rerun = this._rerun;
        }

        // Check for updates
        if (this._options.checkUpdates === true) {
            await this.checkUpdates()
                .catch(() => {});
        }

        let output = this._outputBuffer;

        // Output JSON
        console.log(JSON.stringify(output, null, '\t'));

        // Reset output buffer
        this._outputBuffer = {};

        return output;
    }

    /**
     * Fetch url and parse JSON. Useful for REST APIs.
     * @see https://www.npmjs.com/package/got
     * @param {string} url Url to request
     * @param {Object} options http.request options
     * @param {number|null} cacheAge Cache lifetime (in seconds), above 0 to enable or null to disable.
     * @return {Object|string}
     * @async
     */
    async fetch(url: string, options: Object = {}, cacheAge: ?number = null): Object|string {
        // Set default options
        options = Object.assign({}, {
            json: true
        }, options);

        // Check cache for a hit
        if (cacheAge && cacheAge > 0) {
            let cacheResult: Object|string|null = this.cache.get(url);

            if (cacheResult) {
                return cacheResult;
            }
        }

        // Do request
        return got(url, options)
            .then(response => {
                if (cacheAge && cacheAge > 0) {
                    this.cache.set(url, response.body, {
                        maxAge: cacheAge * 1000
                    });
                }

                return response.body;
            });
    }
}

module.exports = new Hugo();
