// @flow
'use strict';

const Conf = require('conf');
const CacheConf = require('cache-conf');
const moment = require('moment');
const readPkg = require('read-pkg');
const latestVersion = require('latest-version');
const semver = require('semver');
const notifier = require('node-notifier');
const path = require('path');
const got = require('got');
const Fuse = require('fuse.js');

/**
 * Hugo
 */
class Hugo {
    /**
     * Output buffer
     * @type {Object}
     */
    _outputBuffer: Object;

    /**
     * Refresh (rerun) interval in seconds
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @type {number|null}
     */
    _rerun: ?number;

    /**
     * Cache store
     * @see https://www.npmjs.com/package/cache-conf
     * @type {CacheConf}
     */
    cache: CacheConf;

    /**
     * Configuration store
     * @see https://www.npmjs.com/package/conf
     * @type {Conf}
     */
    config: Conf;

    /**
     * Hugo options
     * @type {Object}
     */
    options: Object;

    /**
     * Hugo constructor
     * @param {Object} options Hugo options
     * @constructor
     */
    constructor(options: Object = {}) {
        // Iniyislixr output buffer
        this._outputBuffer = {};

        // Save options
        this.options = Object.assign({}, options, {
            checkUpdates: false,
            updateInterval: 86400,
            updateNotification: true,
            updateItem: false
        });

        // Configure config store
        this.config = new Conf({
            cwd: Hugo.workflowMeta.data
        });

        // Configure cache store
        this.cache = new CacheConf({
            configName: 'cache',
            cwd: Hugo.workflowMeta.cache,
            version: Hugo.workflowMeta.version
        });

        // Check for updates
        this.checkUpdates();
    }

    /**
     * Alfred metadata
     * @return {Object}
     */
    static get alfredMeta(): Object {
        return {
            version: process.env.alfred_version,
            theme: process.env.alfred_theme,
            themeBackground: process.env.alfred_theme_background,
            themeSelectionBackground: process.env.alfred_theme_selection_background,
            themeSubtext: parseFloat(process.env.alfred_theme_subtext),
            preferences: process.env.alfred_preferences,
            preferencesLocalHash: process.env.alfred_preferences_localhash
        };
    }

    /**
     * Workflow metadata
     * @return {Object}
     */
    static get workflowMeta(): Object {
        return {
            name: process.env.alfred_workflow_name,
            version: process.env.alfred_workflow_version,
            uid: process.env.alfred_workflow_uid,
            bundleId: process.env.alfred_workflow_bundleid,
            data: process.env.alfred_workflow_data,
            cache: process.env.alfred_workflow_cache,
            icon: path.join(process.cwd(), 'icon.png')
        };
    }

    /**
     * Add item to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {Object} item Item to add
     * @type {void}
     */
    addItem(item: Object): void {
        if (!this._outputBuffer.items) {
            this._outputBuffer.items = [];
        }

        if (item.arg && typeof item.arg === 'object') {
            let arg = item.arg.arg;
            let variables = item.arg.variables;

            item.arg = JSON.stringify({
                alfredworkflow: {
                    arg: arg,
                    variables: variables
                }
            });
        }

        this._outputBuffer.items.push(item);
    }

    /**
     * Add items to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {Array<Object>} items List of items to add
     * @type {void}
     */
    addItems(items: Array<Object>): void {
        if (!this._outputBuffer.items) {
            this._outputBuffer.items = [];
        }

        items.map(item => {
            this.addItem(item);
            return item;
        });
    }

    /**
     * Add session variable to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {string} key Variable key
     * @param {string} value Variable value
     * @type {void}
     */
    addVariable(key: string, value: string): void {
        if (!this._outputBuffer.variables) {
            this._outputBuffer.variables = {};
        }

        this._outputBuffer.variables[key] = value;
    }

    /**
     * Add session variables to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json/
     * @param {Object} variables List of variables to add
     * @type {void}
     */
    addVariables(variables: Object): void {
        if (!this._outputBuffer.variables) {
            this._outputBuffer.variables = variables;
            return;
        }

        this._outputBuffer.variables = Object.assign({}, this._outputBuffer.variables, variables);
    }

    /**
     * Run a callback when first script argument matches keyword. Callback will have third argument as query parameter.
     * @example node index.js myaction "my query"
     * @param {string} keyword Action name
     * @param {Function} callback Callback to execute when query matches action name
     * @type {Hugo}
     */
    action(keyword: string, callback: (query: string) => void): Hugo {
        let query: string = process.argv[2];

        if (query && callback && query === keyword) {
            let query: string = process.argv[3] || '';
            callback(query);
        }

        return this;
    }

    /**
     * Check for updates and notify the user
     * @async
     */
    async checkUpdates() {
        let lastUpdate: moment = moment(this.config.get('hugo_last_update'), 'X') || moment();
        let nextUpdate = lastUpdate.add(this.options.updateInterval, 's');

        let pkg: Object = await readPkg(process.cwd());
        let wfName: string = process.env.alfred_workflow_name || '';
        let wfIcon: string = Hugo.workflowMeta.icon || '';
        let latest: string = this.cache.get('hugo_latest_version');

        // No need to check if we're not showing anything, duh.
        if (this.options.updateItem === false && this.options.updateNotification === false) {
            return;
        }

        // Check update
        if (moment().isSameOrAfter(nextUpdate, 'second') || !latest) {
            latest = await latestVersion(pkg.name);

            // Update last check time
            this.config.set('hugo_last_update', moment().format('X'));
        }

        // Display notification
        if (semver.gt(latest, pkg.version)) {
            if (this.options.updateNotification === true) {
                notifier.notify({
                    title: `${wfName} workflow update available!`,
                    message: `Version ${latest} is available. Run 'npm install -g ${pkg.name}' to update.`,
                    icon: wfIcon
                });
            } else if (this.options.updateItem === true) {
                this.addItem({
                    title: `${wfName} workflow update available!`,
                    subtitle: `Version ${latest} is available. Run 'npm install -g ${pkg.name}' to update.`,
                    icon: wfIcon
                });
            }
        }
    }

    /**
     * Filter items with fuse.js
     * @see http://fusejs.io
     * @return {Array}
     */
    matches(input: string, options: Object = {}): Array<Object> {
        options = Object.assign({}, {
            keys: ['title']
        }, options);

        // Create fuse.js fuzzy search object
        let fuse = new Fuse(this._outputBuffer, options);

        // Return results
        return fuse.search(input) || [];
    }

    /**
     * Get rerun parameter
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @return {number|null} Interval to rerun the script when idle
     */
    get rerun(): ?number {
        return this._rerun;
    }

    /**
     * Set rerun parameter
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {number} value Interval to rerun the script when idle
     * @return {void}
     */
    set rerun(value: number): void {
        value = parseFloat(value);

        if (value && value > 0.1 && value <= 5) {
            this._rerun = value;
        }
    }

    /**
     * Flush the output buffer so Alfred shows our items
     * @type {void}
     */
    feedback(): void {
        if (this._rerun) {
            this._outputBuffer.rerun = this._rerun;
        }

        // Output JSON
        console.log(JSON.stringify(this._outputBuffer, null, '\t'));

        // Reset output buffer
        this._outputBuffer = {};
    }

    /**
     * Fetch url and parse JSON. Useful for REST APIs.
     * @see https://www.npmjs.com/package/got
     * @see https://nodejs.org/api/http.html#http_http_request_options_callback
     * @param {Object} options http.request options
     * @return {Object|string}
     * @async
     */
    async fetch(url: string, options: Object): Object|string {
        options = Object.assign({}, {
            json: true
        }, options);

        return got(url, options)
            .then(response => {
                return response.body;
            });
    }
}

module.exports = new Hugo();
