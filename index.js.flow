// @flow
'use strict';

import Conf from 'conf';
import CacheConf from 'cache-conf';
import moment from 'moment';
import readPkg from 'read-pkg';
import latestVersion from 'latest-version';
import semver from 'semver';
import notifier from 'node-notifier';
import path from 'path';
import got from 'got';
import Fuse from 'fuse.js';

/**
 * Hugo
 */
class Hugo {
    /**
     * FuseJS defaults
     * @see https://github.com/krisk/fuse#options
     * @type {Object}
     */
    _fuseDefaults: Object;

    /**
     * Hugo options
     * @type {Object}
     */
    _options: Object;

    /**
     * Output buffer
     * @type {Object}
     */
    _outputBuffer: Object;

    /**
     * Refresh (rerun) interval in seconds
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @type {number|null}
     */
    _rerun: ?number;

    /**
     * Cache store
     * @see https://www.npmjs.com/package/cache-conf
     * @type {CacheConf}
     */
    cache: CacheConf;

    /**
     * Configuration store
     * @see https://www.npmjs.com/package/conf
     * @type {Conf}
     */
    config: Conf;

    /**
     * Hugo constructor
     * @constructor
     */
    constructor() {
        // Set defaults for FuseJS
        this._fuseDefaults = {
            keys: ['title'],
            threshold: 0.4
        };

        // Save options
        this._options = {
            checkUpdates: true,
            updateInterval: moment.duration(1, 'days'),
            updateNotification: true,
            updateItem: false
        };

        // Initialize output buffer
        this._outputBuffer = {};

        // Configure config store
        this.config = new Conf({
            cwd: Hugo.workflowMeta.data
        });

        // Configure cache store
        this.cache = new CacheConf({
            configName: 'cache',
            cwd: Hugo.workflowMeta.cache,
            version: Hugo.workflowMeta.version
        });
    }

    /**
     * Alfred metadata
     * @return {Object}
     */
    static get alfredMeta(): Object {
        return {
            version: process.env.alfred_version,
            theme: process.env.alfred_theme,
            themeBackground: process.env.alfred_theme_background,
            themeSelectionBackground: process.env.alfred_theme_selection_background,
            themeSubtext: parseFloat(process.env.alfred_theme_subtext),
            preferences: process.env.alfred_preferences,
            preferencesLocalHash: process.env.alfred_preferences_localhash,
            debug: process.env.alfred_debug === 1
        };
    }

    /**
     * Workflow metadata
     * @return {Object}
     */
    static get workflowMeta(): Object {
        return {
            name: process.env.alfred_workflow_name,
            version: process.env.alfred_workflow_version,
            uid: process.env.alfred_workflow_uid,
            bundleId: process.env.alfred_workflow_bundleid,
            data: process.env.alfred_workflow_data,
            cache: process.env.alfred_workflow_cache,
            icon: path.join(process.cwd(), 'icon.png')
        };
    }

    /**
     * Add item to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {Object} item Item to add
     * @type {void}
     */
    addItem(item: Object): void {
        if (!this._outputBuffer.items) {
            this._outputBuffer.items = [];
        }

        if (!item.title) {
            if (Hugo.alfredMeta.debug === true) {
                console.error('Item skipped, missing title.');
            }
            return;
        }

        if (item.arg && typeof item.arg === 'object') {
            let arg = item.arg.arg;
            let variables = item.arg.variables;

            item.arg = JSON.stringify({
                alfredworkflow: {
                    arg: arg,
                    variables: variables
                }
            });
        }

        this._outputBuffer.items.push(item);
    }

    /**
     * Add items to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {Array<Object>} items List of items to add
     * @type {void}
     */
    addItems(items: Array<Object>): void {
        if (!this._outputBuffer.items) {
            this._outputBuffer.items = [];
        }

        items.map(item => {
            this.addItem(item);
            return item;
        });
    }

    /**
     * Add session variable to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {string} key Variable key
     * @param {string} value Variable value
     * @type {void}
     */
    addVariable(key: string, value: string): void {
        if (!this._outputBuffer.variables) {
            this._outputBuffer.variables = {};
        }

        this._outputBuffer.variables[key] = value;
    }

    /**
     * Add session variables to output buffer
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json/
     * @param {Object} variables List of variables to add
     * @type {void}
     */
    addVariables(variables: Object): void {
        if (!this._outputBuffer.variables) {
            this._outputBuffer.variables = variables;
            return;
        }

        this._outputBuffer.variables = Object.assign({}, this._outputBuffer.variables, variables);
    }

    /**
     * Run a callback when first script argument matches keyword. Callback will have third argument as query parameter.
     * @example node index.js myaction "my query"
     * @param {string} keyword Action name
     * @param {Function} callback Callback to execute when query matches action name
     * @type {Hugo}
     */
    action(keyword: string, callback: (query: string) => void): Hugo {
        let query: string = process.argv[2];

        if (query && callback && query === keyword) {
            query = process.argv[3] || '';
            callback(query);
        }

        return this;
    }

    /**
     * Check for updates and notify the user
     * @async
     */
    async checkUpdates() {
        // No need to check if we're not showing anything, duh.
        if (this._options.checkUpdates !== true ||
                (this._options.updateItem !== true && this._options.updateNotification !== true)) {
            return;
        }

        // Get package information
        let pkg: Object = await readPkg(process.cwd());
        let wfName: string = Hugo.workflowMeta.name || '';
        let wfIcon: string = Hugo.workflowMeta.icon || '';
        let latest: string = this.cache.get('hugo_latest_version');
        let checkedOnline: boolean = false;

        // Don't do anything if the package wasn't found last time.
        if (latest === false) {
            return;
        }

        // Check update
        if (latest === null) {
            latest = await latestVersion(pkg.name)
                .catch(() => {
                    // Return false on failure (e.g. not found).
                    return false;
                });

            // We checked online for updates
            checkedOnline = true;

            // Update last check time
            this.cache.set('hugo_latest_version', latest, {
                maxAge: this._options.updateInterval.as('milliseconds')
            });
        }

        // Display notification
        if (latest && semver.gt(latest, pkg.version)) {
            if (checkedOnline === true && this._options.updateNotification === true) {
                notifier.notify({
                    title: wfName,
                    subtitle: `Workflow version ${latest} available`,
                    message: `Run 'npm install -g ${pkg.name}' to update.`,
                    sender: 'com.runningwithcrayons.Alfred-3',
                    timeout: 10
                });
            }
            if (this._options.updateItem === true) {
                this.addItem({
                    title: `Workflow update available!`,
                    subtitle: `Version ${latest} is available. Run 'npm install -g ${pkg.name}' to update.`,
                    icon: wfIcon,
                    arg: {
                        arg: `npm update -g ${pkg.name}`,
                        variables: {
                            task: 'wfUpdate'
                        }
                    }
                });
            }
        }
    }

    /**
     * Filter added items (output buffer) with fuse.js
     * @see http://fusejs.io
     * @param {string} query Search string
     * @param {Object} options fuse.js options
     * @return {void}
     */
    filterItems(query: string, options: Object = {}): void {
        options = Object.assign({}, this._fuseDefaults, options);

        if (query.length === 0) {
            return;
        }

        // Create fuse.js fuzzy search object
        let fuse = new Fuse(this._outputBuffer.items, options);

        // Set output buffer to matching items
        this._outputBuffer.items = fuse.search(query) || [];
    }

    /**
     * Set Hugo options
     * @param {Object} value Options to set
     * @return {void}
     */
    options(value: Object): void {
        // Convert updateInterval to moment.Duration object
        if (value.updateInterval && !moment.isDuration(value.updateInterval)) {
            value.updateInterval = moment.duration(value.updateInterval) || moment.duration(1, 'days');
        }

        this._options = Object.assign({}, this._options, value);
    }

    /**
     * Filter list of candidates with fuse.js
     * @see http://fusejs.io
     * @param {Array<Object>} candidates Input data
     * @param {string} query Search string
     * @param {Object} options fuse.js options
     * @return {Array<Object>}
     */
    matches(candidates: Array<Object>, query: string, options: Object = {}): Array<Object> {
        options = Object.assign({}, this._fuseDefaults, options);

        if (query.length === 0) {
            return candidates;
        }

        // Create fuse.js fuzzy search object
        let fuse = new Fuse(candidates, options);

        // Return results
        return fuse.search(query) || [];
    }

    /**
     * Set rerun parameter
     * @see https://www.alfredapp.com/help/workflows/inputs/script-filter/json
     * @param {number} value Interval to rerun the script when idle
     * @return {Hugo}
     */
    rerun(value: number): Hugo {
        value = parseFloat(value);

        if (value && value > 0.1 && value <= 5) {
            this._rerun = value;
        }

        return this;
    }

    /**
     * Flush the output buffer so Alfred shows our items
     * @async
     */
    async feedback() {
        if (this._rerun) {
            this._outputBuffer.rerun = this._rerun;
        }

        // Check for updates
        if (this._options.checkUpdates === true) {
            await this.checkUpdates()
                .catch(() => {});
        }

        let output = this._outputBuffer;

        // Output JSON
        console.log(JSON.stringify(output, null, '\t'));

        // Reset output buffer
        this._outputBuffer = {};

        return output;
    }

    /**
     * Fetch url and parse JSON. Useful for REST APIs.
     * @see https://www.npmjs.com/package/got
     * @param {string} url Url to request
     * @param {Object} options http.request options
     * @param {number|null} cacheAge Cache lifetime (in seconds), above 0 to enable or null to disable.
     * @return {Object|string}
     * @async
     */
    async fetch(url: string, options: Object = {}, cacheAge: ?number = null): Object|string {
        // Set default options
        options = Object.assign({}, {
            json: true
        }, options);

        // Check cache for a hit
        if (cacheAge && cacheAge > 0) {
            let cacheResult: ?Object|?string = this.cache.get(url);

            if (cacheResult) {
                return cacheResult;
            }
        }

        // Do request
        return got(url, options)
            .then(response => {
                if (cacheAge && cacheAge > 0) {
                    this.cache.set(url, response.body, {
                        maxAge: cacheAge * 1000
                    });
                }

                return response.body;
            });
    }
}

module.exports = new Hugo();
