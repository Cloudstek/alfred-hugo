// @flow

const crypto = require('crypto');
const EventEmitter = require('events').EventEmitter;
const fs = require('fs-extra');
const path = require('path');

/**
 * FileCache
 * Simple in-memory key/value pair storage to store event listener results
 */
class FileCacheStore {
    /**
     * Cache contents
     * @type {Object|Array.<Object>}
     */
    _contents: Object|Array<Object>;

    /**
     * FileCacheStore constructor
     * @constructor
     */
    constructor() {
        this._contents = {};
    }

    /**
     * Get cache contents
     * @return {Object|Array.<Object>} Cache contents
     */
    get contents() {
        return this._contents;
    }

    /**
     * Set cache contents to value
     * @param {Object|Arrray.<Object>} value Value to store
     * @return {FileCacheStore} Self
     */
    store(value: Object|Array<Object>): FileCacheStore {
        this._contents = value;
        return this;
    }

    /**
     * Set a cache value
     * @param {any} key Key
     * @param {any} value Value
     * @return {FileCacheStore} Self
     */
    set(key: any, value: any): FileCacheStore {
        this._contents[key] = value;
        return this;
    }
}

/**
 * FileCache
 */
class FileCache extends EventEmitter {
    filePath: string;

    cacheName: string;

    cacheDir: string;

    isCleaning: boolean;

    /**
     * FileCache constructor
     * @param {string} filePath File to process and check for changes
     * @param {string} cacheName Unique name for cache directory
     * @param {string} cacheDir Cache base directory
     * @constructor
     */
    constructor(filePath: string, cacheName: string, cacheDir: string) {
        super();

        this.filePath = filePath;
        this.cacheName = cacheName;
        this.cacheDir = cacheDir;
        this.isCleaning = false;
    }

    /**
     * Check if file exists
     * @param {string} path
     * @return {boolean}
     */
    _fileExists(path: string): boolean {
        try {
            fs.statSync(path);
            return true;
        } catch (err) {
            return false;
        }
    }

    /**
     * Get cached contents
     * @return {Object|Array.<Object>|null}
     */
    get(): Object|Array<Object>|null {
        if (this._fileExists(this.filePath)) {
            // Create simple in-memory store for event listener results
            let eventResult = new FileCacheStore();

            // Read file
            let file = fs.readFileSync(this.filePath, 'utf8');

            // Calculate file hash
            let hash = crypto.createHash('sha1').update(file, 'utf8').digest('hex');

            // Always call callback when cache dir is not set
            if (!this.cacheDir) {
                this.emit('change', eventResult, file, hash);
                return eventResult.contents;
            }

            // Get cache path
            let cachePath = path.join(this.cacheDir, this.cacheName, hash);

            // Return cached data if found
            if (this._fileExists(cachePath)) {
                return fs.readJsonSync(cachePath, {throws: false});
            }

            // Create cache directory if it doesn't exist
            fs.ensureDirSync(path.dirname(cachePath));

            // Get processed data
            this.emit('change', eventResult, file, hash);

            // Write cache
            fs.writeJsonSync(cachePath, eventResult.contents);
            return eventResult.contents;
        }

        return null;
    }

    /**
     * Clear cache
     * @async
     * @return {Promise}
     */
    async clearCache() {
        if (!this.cacheDir) {
            return;
        }

        return fs.emptyDir(path.join(this.cacheDir, this.cacheName));
    }

    /**
     * Clear cache synchronously
     * @return {void}
     */
    clearCacheSync() {
        if (!this.cacheDir) {
            return;
        }

        return fs.emptyDirSync(path.join(this.cacheDir, this.cacheName));
    }
}

module.exports = FileCache;
